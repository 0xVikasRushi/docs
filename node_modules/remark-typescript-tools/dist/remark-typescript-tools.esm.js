import flatMap from 'unist-util-flatmap';
import ts from 'typescript';
import path, { normalize } from 'path';
import { DocFencedCode, DocExcerpt, TextRange, TSDocConfiguration, TSDocTagDefinition, TSDocTagSyntaxKind, TSDocParser } from '@microsoft/tsdoc';
import { URL } from 'url';
import visit from 'unist-util-visit';
import prettier from 'prettier';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

/**
 * Retrieves the JSDoc-style comments associated with a specific AST node.
 *
 * Based on ts.getJSDocCommentRanges() from the compiler.
 * https://github.com/Microsoft/TypeScript/blob/v3.0.3/src/compiler/utilities.ts#L924
 */

function getJSDocCommentRanges(node, text) {
  /** @type {import('typescript').CommentRange[]} */
  var commentRanges = [];

  switch (node.kind) {
    case ts.SyntaxKind.Parameter:
    case ts.SyntaxKind.TypeParameter:
    case ts.SyntaxKind.FunctionExpression:
    case ts.SyntaxKind.ArrowFunction:
    case ts.SyntaxKind.ParenthesizedExpression:
    case ts.SyntaxKind.VariableDeclaration:
    case ts.SyntaxKind.VariableStatement:
      commentRanges.push.apply(commentRanges, ts.getTrailingCommentRanges(text, node.pos) || []);
      break;
  }

  commentRanges.push.apply(commentRanges, ts.getLeadingCommentRanges(text, node.pos) || []); // True if the comment starts with '/**' but not if it is '/**/'

  return commentRanges.filter(function (comment) {
    return text.charCodeAt(comment.pos + 1) === 0x2a
    /* ts.CharacterCodes.asterisk */
    && text.charCodeAt(comment.pos + 2) === 0x2a
    /* ts.CharacterCodes.asterisk */
    && text.charCodeAt(comment.pos + 3) !== 0x2f;
  }
  /* ts.CharacterCodes.slash */
  );
}
function renderDocNode(docNode) {
  if (!docNode) {
    return '';
  }

  if (Array.isArray(docNode)) {
    return docNode.map(function (node) {
      return renderDocNode(node);
    }).join('');
  }

  var result = '';

  if (docNode) {
    if (docNode instanceof DocFencedCode) {
      var code = docNode.code.toString();
      var meta = '';
      code = code.replace(/^\s*\/\/\s*codeblock-meta(\s.*?)$\n?/gm, function (_line, metaMatch) {
        meta += metaMatch;
        return '';
      });
      return '```' + docNode.language + meta + '\n' + code + '\n```';
    }

    if (docNode instanceof DocExcerpt) {
      result += docNode.content.toString();
    }

    for (var _iterator = _createForOfIteratorHelperLoose(docNode.getChildNodes()), _step; !(_step = _iterator()).done;) {
      var childNode = _step.value;
      result += renderDocNode(childNode);
    }
  }

  return result;
}

var Extractor = /*#__PURE__*/function () {
  function Extractor(_ref) {
    var tsconfig = _ref.tsconfig,
        rootFiles = _ref.rootFiles,
        basedir = _ref.basedir;
    this.basedir = basedir;
    var configFile = ts.readConfigFile(tsconfig, ts.sys.readFile);
    var compilerOptions = ts.parseJsonConfigFileContent(configFile.config, ts.sys, './').options;
    var compilerHost = ts.createCompilerHost(compilerOptions);
    this.program = ts.createProgram(rootFiles.map(function (file) {
      return path.resolve(basedir, file);
    }), compilerOptions, compilerHost);
  }

  var _proto = Extractor.prototype;

  _proto.findTokens = function findTokens(token, node) {
    var _this = this;

    var _token$split = token.split('.'),
        lookFor = _token$split[0],
        tail = _token$split.slice(1);

    var found = [];
    node.forEachChild(function (child) {
      if (ts.isVariableStatement(child)) {
        found.push.apply(found, _this.findTokens(token, child.declarationList));

        if (child.declarationList.declarations.length === 1) {
          var _name = child.declarationList.declarations[0].name;

          if (_name && ts.isIdentifier(_name) && _name.escapedText === lookFor) {
            // push the whole declarationList if it contains only one declaration, for "outside style"
            found.push(child);
          }
        }

        return;
      }

      var name = child.name;

      if (name && ts.isIdentifier(name) && name.escapedText === lookFor) {
        if (lookFor === token) {
          if (ts.isVariableDeclaration(child) && child.initializer) {
            // push the initializer for "inside" style
            found.push(child.initializer);
          }

          found.push(child);
        } else {
          found.push.apply(found, _this.findTokens(tail.join('.'), child));
        }
      }
    });
    return found;
  };

  _proto.getComment = function getComment(token, fileName, overload) {
    if (fileName === void 0) {
      fileName = 'index.ts';
    }

    if (overload === void 0) {
      overload = 0;
    }

    var inputFileName = path.resolve(this.basedir, fileName);
    var sourceFile = this.program.getSourceFile(inputFileName);

    if (!sourceFile) {
      throw new Error("Error retrieving source file " + sourceFile + " (looked for " + fileName + " in " + this.basedir + ")");
    }

    var foundComments = [];
    var buffer = sourceFile.getFullText();

    for (var _iterator = _createForOfIteratorHelperLoose(this.findTokens(token, sourceFile)), _step; !(_step = _iterator()).done;) {
      var node = _step.value;
      var comments = getJSDocCommentRanges(node, buffer);

      if (comments.length > 0) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(comments), _step2; !(_step2 = _iterator2()).done;) {
          var comment = _step2.value;
          foundComments.push({
            compilerNode: node,
            textRange: TextRange.fromStringRange(buffer, comment.pos, comment.end)
          });
        }
      }
    }

    var customConfiguration = new TSDocConfiguration();
    customConfiguration.addTagDefinition(new TSDocTagDefinition({
      tagName: '@overloadSummary',
      syntaxKind: TSDocTagSyntaxKind.BlockTag
    }));
    customConfiguration.addTagDefinition(new TSDocTagDefinition({
      tagName: '@overloadRemarks',
      syntaxKind: TSDocTagSyntaxKind.BlockTag
    }));
    var tsdocParser = new TSDocParser(customConfiguration);
    var selectedOverload = foundComments[overload];

    if (!selectedOverload) {
      console.warn("could not find overload " + overload + " for " + token + " in " + fileName);
      return null;
    }

    var parserContext = tsdocParser.parseRange(selectedOverload.textRange);
    var docComment = parserContext.docComment;
    return Object.assign(docComment, {
      parserContext: parserContext,
      buffer: selectedOverload.textRange.buffer,
      overloadSummary: docComment.customBlocks.find(this.byTagName('@overloadSummary')),
      overloadRemarks: docComment.customBlocks.find(this.byTagName('@overloadRemarks')),
      examples: docComment.customBlocks.filter(this.byTagName('@example'))
    });
  };

  _proto.byTagName = function byTagName(name) {
    return function (block) {
      return block.blockTag.tagName === name;
    };
  };

  return Extractor;
}();

// @ts-ignore
var extractors = /*#__PURE__*/new WeakMap();
var attacher = function attacher(_ref) {
  var _this = this;

  var extractorSettings = _ref.extractorSettings;

  if (!extractors.has(extractorSettings)) {
    extractors.set(extractorSettings, new Extractor(extractorSettings));
  }

  var extractor = extractors.get(extractorSettings);

  var parseNodes = function parseNodes(markdown) {
    return _this.parse(markdown).children;
  };

  function renderAsMarkdown(key, prepare) {
    if (prepare === void 0) {
      prepare = function prepare(str) {
        return str;
      };
    }

    function render(comment) {
      var docBlock = comment[key];
      var rendered = renderDocNode(docBlock);
      return parseNodes(prepare(rendered));
    }

    return render;
  }

  var sectionMapping = {
    summary: renderAsMarkdown('summarySection', function (s) {
      return s.replace(/@summary/g, '');
    }),
    remarks: renderAsMarkdown('remarksBlock', function (s) {
      return s.replace(/@remarks/g, '');
    }),
    overloadSummary: renderAsMarkdown('overloadSummary', function (s) {
      return s.replace(/@overloadSummary/g, '');
    }),
    overloadRemarks: renderAsMarkdown('overloadRemarks', function (s) {
      return s.replace(/@overloadRemarks/g, '');
    }),
    examples: renderAsMarkdown('examples', function (s) {
      return s.replace(/@example/g, '');
    }),
    params: renderAsMarkdown('params', function (s) {
      return s.replace(/@param (.*) -/g, '* **$1**');
    })
  };
  return function transformer(tree) {
    return flatMap(tree, function mapper(parent) {
      if (!(parent.type === 'paragraph' && parent.children.length === 1)) {
        return [parent];
      }

      var node = parent.children[0];

      if (node.type !== 'link' || !node.url.startsWith('docblock://')) {
        return [parent];
      }

      if (node.children.length !== 1 || node.children[0].type !== 'text') {
        throw new Error('invalid meta content for docblock link');
      }

      var meta = node.children[0].value;
      var sections = meta.split(',').map(function (s) {
        return s.trim();
      });
      var url = new URL(node.url);
      var fileName = url.host + url.pathname;
      var args = url.searchParams;
      var token = args.get('token');
      var overload = Number.parseInt(args.get('overload') || '0');

      if (!token) {
        throw new Error('token name must be provided as query parameter `token`');
      }

      var comment = extractor.getComment(token, fileName, overload);

      if (!comment) {
        return [];
      }

      var retVal = sections.reduce(function (acc, section) {
        if (!(section in sectionMapping)) {
          throw new Error("invalid comment section reference. valid references are " + Object.keys(sectionMapping).concat(','));
        }

        acc.push.apply(acc, sectionMapping[section](comment));
        return acc;
      }, []);
      visit({
        type: 'fakeRoot',
        children: retVal
      }, 'code', function (node) {
        node.value = node.value.trimEnd();
      });
      return retVal;
    });
  };
};

var Compiler = /*#__PURE__*/function () {
  function Compiler(settings) {
    var configFile = ts.readConfigFile(settings.tsconfig, ts.sys.readFile);
    this.compilerOptions = ts.parseJsonConfigFileContent(configFile.config, ts.sys, './').options;
    this.compilerHost = createCompilerHost(this.compilerOptions, settings.externalResolutions);
    this.service = ts.createLanguageService(this.compilerHost, ts.createDocumentRegistry());
  }

  var _proto = Compiler.prototype;

  _proto.compile = function compile(files) {
    // console.log(compilerOptions)
    this.compilerHost.setScriptFileNames([]);

    for (var _i = 0, _Object$entries = Object.entries(files); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          fileName = _Object$entries$_i[0],
          code = _Object$entries$_i[1].code;
      code = code.replace(/^$/gm, '//__NEWLINE__');
      this.compilerHost.writeFile(fileName, code);
    }

    this.compilerHost.setScriptFileNames(Object.keys(files));
    var returnFiles = {};

    for (var _i2 = 0, _Object$entries2 = Object.entries(files); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _Object$entries2[_i2],
          _fileName = _Object$entries2$_i[0];
      var emitResult = this.service.getEmitOutput(_fileName);
      var emittedFile = emitResult.outputFiles.find(function (_ref) {
        var name = _ref.name;
        return name.endsWith('.js') || name.endsWith('.jsx');
      });
      var transpiledCode = emittedFile ? emittedFile.text.replace(/\/\/__NEWLINE__/g, '') : '';
      var allDiagnostics = this.service.getCompilerOptionsDiagnostics().concat(this.service.getSyntacticDiagnostics(_fileName)).concat(this.service.getSemanticDiagnostics(_fileName));
      var diagnostics = allDiagnostics.map(function (diagnostic) {
        var message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');

        if (diagnostic.file && diagnostic.start) {
          var _diagnostic$file$getL = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start),
              line = _diagnostic$file$getL.line,
              character = _diagnostic$file$getL.character;

          return {
            line: line,
            character: character,
            message: message
          };
        }

        return {
          message: message
        };
      });
      returnFiles[_fileName] = _extends({}, files[_fileName], {
        code: transpiledCode,
        diagnostics: diagnostics
      });
    }

    return returnFiles;
  };

  return Compiler;
}();

function createCompilerHost(compilerOptions, externalResolutions) {
  var virtualFiles = {};
  var scriptFileNames = [];
  return _extends({}, ts.createCompilerHost(compilerOptions), {
    getCompilationSettings: function getCompilationSettings() {
      return compilerOptions;
    },
    fileExists: function fileExists(fileName) {
      // console.log('fileExists', fileName)
      return !!virtualFiles[normalize(fileName)] || ts.sys.fileExists(fileName);
    },
    readFile: function readFile(fileName) {
      // console.log('readFile', fileName)
      var virtual = virtualFiles[normalize(fileName)];
      return virtual ? virtual.contents : ts.sys.readFile(fileName);
    },
    writeFile: function writeFile(fileName, contents) {
      fileName = normalize(fileName);
      var version = virtualFiles[fileName] ? virtualFiles[fileName].version : 1;

      if (virtualFiles[fileName] && virtualFiles[fileName].contents !== contents) {
        version++;
      }

      virtualFiles[fileName] = {
        contents: contents,
        version: version
      };
    },
    directoryExists: function directoryExists(dirName) {
      var normalized = normalize(dirName + '/');
      return scriptFileNames.some(function (fileName) {
        return fileName.startsWith(normalized);
      }) || ts.sys.directoryExists(dirName);
    },
    setScriptFileNames: function setScriptFileNames(files) {
      scriptFileNames = files.map(normalize); // console.log({ virtualFiles, scriptFileNames })
    },
    getScriptFileNames: function getScriptFileNames() {
      return scriptFileNames;
    },
    getScriptSnapshot: function getScriptSnapshot(fileName) {
      var contents = this.readFile(fileName);
      return contents ? ts.ScriptSnapshot.fromString(contents) : undefined;
    },
    getScriptVersion: function getScriptVersion(fileName) {
      var virtual = virtualFiles[normalize(fileName)];
      return virtual ? virtual.version.toString() : String(ts.sys.getModifiedTime && ts.sys.getModifiedTime(fileName) || 'unknown, will not update without restart');
    },
    resolveModuleNames: function resolveModuleNames(moduleNames, containingFile) {
      var _this = this;

      return moduleNames.map(function (moduleName) {
        if (moduleName in externalResolutions) {
          var resolved = externalResolutions[moduleName];
          var resolvedModule = ts.resolveModuleName(resolved.resolvedPath, containingFile, compilerOptions, _this).resolvedModule;

          if (!resolvedModule) {
            throw new Error("external resolution " + moduleName + " not found");
          }

          return _extends({}, resolvedModule, {
            packageId: resolved.packageId
          });
        }

        return ts.resolveModuleName(moduleName, containingFile, compilerOptions, _this).resolvedModule;
      });
    }
  });
}

function postProcessTs(files, parentFile) {
  return fromEntries(Object.entries(files).map(function (_ref) {
    var name = _ref[0],
        file = _ref[1];
    var prettyCode = prettify(file.code, name, parentFile || name);
    return [name, _extends({}, file, {
      code: prettyCode.trim()
    })];
  }));
}
function postProcessTranspiledJs(files, parentFile) {
  return fromEntries(Object.entries(files).map(function (_ref2) {
    var name = _ref2[0],
        file = _ref2[1];
    var mangledCode = file.code.replace(/(\n\s*|)\/\/ (@ts-ignore|@ts-expect-error).*$/gm, '');
    var prettyCode = prettify(mangledCode, name, parentFile || name);
    return [name, _extends({}, file, {
      code: prettyCode.trim()
    })];
  }));
}
var lastConfig;
var lastParentFile;
/**
 *
 * @param {string} sourceCode
 * @param {string} fileName
 * @param {string} parentFile
 */

function prettify(sourceCode, fileName, parentFile) {
  if (lastParentFile !== parentFile) {
    lastConfig = prettier.resolveConfig.sync(parentFile);
  }

  if (!lastConfig) {
    console.error("no prettier config found for " + parentFile + ", skipping prettier step");
    return sourceCode;
  }

  return prettier.format(sourceCode, _extends({}, lastConfig, {
    filepath: fileName
  }));
}

function fromEntries(entries) {
  var ret = {};

  for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {
    var _step$value = _step.value,
        key = _step$value[0],
        value = _step$value[1];
    ret[key] = value;
  }

  return ret;
}

var compilers = /*#__PURE__*/new WeakMap();
var attacher$1 = function attacher(_ref) {
  var compilerSettings = _ref.compilerSettings,
      _ref$postProcessTrans = _ref.postProcessTranspiledJs,
      postProcessTranspiledJs$1 = _ref$postProcessTrans === void 0 ? postProcessTranspiledJs : _ref$postProcessTrans,
      _ref$postProcessTs = _ref.postProcessTs,
      postProcessTs$1 = _ref$postProcessTs === void 0 ? postProcessTs : _ref$postProcessTs,
      _ref$assembleReplacem = _ref.assembleReplacementNodes,
      assembleReplacementNodes = _ref$assembleReplacem === void 0 ? defaultAssembleReplacementNodes : _ref$assembleReplacem,
      _ref$fileExtensions = _ref.fileExtensions,
      fileExtensions = _ref$fileExtensions === void 0 ? ['.mdx'] : _ref$fileExtensions;

  if (!compilers.has(compilerSettings)) {
    compilers.set(compilerSettings, new Compiler(compilerSettings));
  }

  var compiler = compilers.get(compilerSettings);
  return function transformer(tree, file) {
    if (!file.extname || !fileExtensions.includes(file.extname)) {
      return tree;
    }

    var hasTabsImport = false;
    var hasTabItemImport = false;
    visit(tree, 'import', function (node) {
      if (/\bTabs\b/.test(node.value)) hasTabsImport = true;
      if (/\bTabItem\b/.test(node.value)) hasTabItemImport = true;
    });
    visit(tree, 'root', function (node) {
      if (!hasTabsImport) {
        node.children.unshift({
          type: 'import',
          value: "import Tabs from '@theme/Tabs'"
        });
      }

      if (!hasTabItemImport) {
        node.children.unshift({
          type: 'import',
          value: "import TabItem from '@theme/TabItem'"
        });
      }
    });
    var codeBlock = 0;
    return flatMap(tree, function mapper(node) {
      if (node.type === 'code') {
        codeBlock++;
      }

      if (!(node.type === 'code' && node.lang === 'ts')) {
        return [node];
      }

      var tags = node.meta ? node.meta.split(' ') : [];

      if (tags.includes('no-transpile')) {
        return [node];
      }

      var virtualFolder = file.path + "/codeBlock_" + codeBlock;
      var virtualFiles = splitFiles(node.value, virtualFolder); //console.time(virtualFolder)

      var transpilationResult = compiler.compile(virtualFiles); //console.timeEnd(virtualFolder)

      for (var _i = 0, _Object$entries = Object.entries(transpilationResult); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _Object$entries[_i],
            fileName = _Object$entries$_i[0],
            result = _Object$entries$_i[1];

        for (var _iterator = _createForOfIteratorHelperLoose(result.diagnostics), _step; !(_step = _iterator()).done;) {
          var diagnostic = _step.value;

          if (diagnostic.line && node.position) {
            var lines = result.code.split('\n').map(function (line, lineNo) {
              return String(lineNo).padStart(3, ' ') + "  " + line;
            });
            file.fail("\nTypeScript error in code block in line " + diagnostic.line + " of " + fileName + "\n" + diagnostic.message + "\n\n" + lines.slice(Math.max(0, diagnostic.line - 5), diagnostic.line + 6).join('\n') + "\n            ", {
              line: diagnostic.line + node.position.start.line,
              column: diagnostic.character
            });
          } else {
            file.fail(diagnostic.message, node);
          }
        }
      }

      return assembleReplacementNodes(node, file, virtualFolder, virtualFiles, transpilationResult, postProcessTs$1, postProcessTranspiledJs$1);
    });
  };
};

function defaultAssembleReplacementNodes(node, file, virtualFolder, virtualFiles, transpilationResult, postProcessTs$1, postProcessTranspiledJs$1) {
  return [{
    type: 'jsx',
    value: "\n    <Tabs\n      groupId=\"language\"\n      defaultValue=\"ts\"\n      values={[\n        { label: 'TypeScript', value: 'ts', },\n        { label: 'JavaScript', value: 'js', },\n      ]}\n    >        \n        <TabItem value=\"ts\">"
  }, _extends({}, node, {
    value: rearrangeFiles(postProcessTs$1(virtualFiles, file.path, postProcessTs), virtualFolder)
  }), {
    type: 'jsx',
    value: "\n        </TabItem>\n        <TabItem value=\"js\">"
  }, _extends({}, node, {
    lang: 'js',
    value: rearrangeFiles(postProcessTranspiledJs$1(transpilationResult, file.path, postProcessTranspiledJs), virtualFolder)
  }), {
    type: 'jsx',
    value: "\n        </TabItem>\n    </Tabs>"
  }];
}

function splitFiles(fullCode, folder) {
  var regex = /^\/\/ file: ([\w\-./]+)(?: (.*))?\s*$/gm;
  var match = regex.exec(fullCode);
  var files = {};

  do {
    var start = match ? match.index + match[0].length + 1 : 0;
    var fileName = match ? match[1] : 'index.ts';
    var flags = (match ? match[2] || '' : '').split(' ');
    var skip = flags.includes('noEmit');
    match = regex.exec(fullCode);
    var end = match ? match.index : fullCode.length;
    var code = fullCode.substring(start, end);
    files[folder + "/" + fileName] = {
      code: code,
      skip: skip
    };
  } while (match);

  return files;
}

function rearrangeFiles(files, folder) {
  var filteredFiles = Object.entries(files).filter(function (_ref2) {
    var skip = _ref2[1].skip;
    return !skip;
  });

  if (filteredFiles.length === 1) {
    var _filteredFiles$ = filteredFiles[0],
        code = _filteredFiles$[1].code;
    return code;
  }

  return filteredFiles.map(function (_ref3) {
    var fileName = _ref3[0],
        code = _ref3[1].code;
    return "// file: " + fileName.replace(folder + '/', '') + "\n" + code.trim();
  }).join('\n\n\n');
}

export { attacher as linkDocblocks, attacher$1 as transpileCodeblocks };
//# sourceMappingURL=remark-typescript-tools.esm.js.map
