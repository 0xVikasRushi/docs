{"version":3,"file":"remark-typescript-tools.cjs.production.min.js","sources":["../src/linkDocblocks/utils.ts","../src/transpileCodeblocks/postProcessing.ts","../src/linkDocblocks/extract.ts","../src/linkDocblocks/plugin.ts","../src/transpileCodeblocks/compiler.ts","../src/transpileCodeblocks/plugin.ts"],"sourcesContent":["import ts from 'typescript';\nimport * as tsdoc from '@microsoft/tsdoc';\n\n/**\n * Retrieves the JSDoc-style comments associated with a specific AST node.\n *\n * Based on ts.getJSDocCommentRanges() from the compiler.\n * https://github.com/Microsoft/TypeScript/blob/v3.0.3/src/compiler/utilities.ts#L924\n */\nexport function getJSDocCommentRanges(node: ts.Node, text: string) {\n  /** @type {import('typescript').CommentRange[]} */\n  const commentRanges: ts.CommentRange[] = [];\n\n  switch (node.kind) {\n    case ts.SyntaxKind.Parameter:\n    case ts.SyntaxKind.TypeParameter:\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.ArrowFunction:\n    case ts.SyntaxKind.ParenthesizedExpression:\n    case ts.SyntaxKind.VariableDeclaration:\n    case ts.SyntaxKind.VariableStatement:\n      commentRanges.push(\n        ...(ts.getTrailingCommentRanges(text, node.pos) || [])\n      );\n      break;\n  }\n  commentRanges.push(...(ts.getLeadingCommentRanges(text, node.pos) || []));\n\n  // True if the comment starts with '/**' but not if it is '/**/'\n  return commentRanges.filter(\n    (comment) =>\n      text.charCodeAt(comment.pos + 1) ===\n        0x2a /* ts.CharacterCodes.asterisk */ &&\n      text.charCodeAt(comment.pos + 2) ===\n        0x2a /* ts.CharacterCodes.asterisk */ &&\n      text.charCodeAt(comment.pos + 3) !== 0x2f /* ts.CharacterCodes.slash */\n  );\n}\n\nexport function renderDocNode(\n  docNode?: tsdoc.DocNode | tsdoc.DocNode[]\n): string {\n  if (!docNode) {\n    return '';\n  }\n  if (Array.isArray(docNode)) {\n    return docNode.map((node) => renderDocNode(node)).join('');\n  }\n\n  let result = '';\n  if (docNode) {\n    if (docNode instanceof tsdoc.DocFencedCode) {\n      let code: string = docNode.code.toString();\n      let meta: string = '';\n      code = code.replace(\n        /^\\s*\\/\\/\\s*codeblock-meta(\\s.*?)$\\n?/gm,\n        (_line, metaMatch) => {\n          meta += metaMatch;\n          return '';\n        }\n      );\n      return '```' + docNode.language + meta + '\\n' + code + '\\n```';\n    }\n    if (docNode instanceof tsdoc.DocExcerpt) {\n      result += docNode.content.toString();\n    }\n\n    for (const childNode of docNode.getChildNodes()) {\n      result += renderDocNode(childNode);\n    }\n  }\n  return result;\n}\n","import { VirtualFiles } from './plugin';\nimport prettier from 'prettier';\n\nexport function postProcessTs(\n  files: VirtualFiles,\n  parentFile?: string\n): VirtualFiles {\n  return fromEntries(\n    Object.entries(files).map(([name, file]) => {\n      const prettyCode = prettify(file.code, name, parentFile || name);\n\n      return [\n        name,\n        {\n          ...file,\n          code: prettyCode.trim(),\n        },\n      ];\n    })\n  );\n}\n\nexport function postProcessTranspiledJs(\n  files: VirtualFiles,\n  parentFile?: string\n): VirtualFiles {\n  return fromEntries(\n    Object.entries(files).map(([name, file]) => {\n      const mangledCode = file.code.replace(\n        /(\\n\\s*|)\\/\\/ (@ts-ignore|@ts-expect-error).*$/gm,\n        ''\n      );\n      const prettyCode = prettify(mangledCode, name, parentFile || name);\n\n      return [\n        name,\n        {\n          ...file,\n          code: prettyCode.trim(),\n        },\n      ];\n    })\n  );\n}\n\nlet lastConfig: prettier.Options | null;\nlet lastParentFile: string;\n\n/**\n *\n * @param {string} sourceCode\n * @param {string} fileName\n * @param {string} parentFile\n */\nfunction prettify(sourceCode: string, fileName: string, parentFile: string) {\n  if (lastParentFile !== parentFile) {\n    lastConfig = prettier.resolveConfig.sync(parentFile);\n  }\n  if (!lastConfig) {\n    console.error(\n      `no prettier config found for ${parentFile}, skipping prettier step`\n    );\n    return sourceCode;\n  }\n  return prettier.format(sourceCode, {\n    ...lastConfig,\n    filepath: fileName,\n  });\n}\n\nfunction fromEntries<T>(entries: Array<[string, T]>): Record<string, T> {\n  const ret: Record<string, T> = {};\n  for (const [key, value] of entries) {\n    ret[key] = value;\n  }\n  return ret;\n}\n","import ts from 'typescript';\nimport path from 'path';\nimport * as tsdoc from '@microsoft/tsdoc';\n\nimport { getJSDocCommentRanges } from './utils';\n\nexport interface ExtractorSettings {\n  tsconfig: string;\n  basedir: string;\n  rootFiles: string[];\n}\n\nexport class Extractor {\n  program: ts.Program;\n  basedir: string;\n\n  constructor({ tsconfig, rootFiles, basedir }: ExtractorSettings) {\n    this.basedir = basedir;\n\n    const configFile = ts.readConfigFile(tsconfig, ts.sys.readFile);\n    const compilerOptions = ts.parseJsonConfigFileContent(\n      configFile.config,\n      ts.sys,\n      './'\n    ).options;\n\n    const compilerHost = ts.createCompilerHost(compilerOptions);\n\n    this.program = ts.createProgram(\n      rootFiles.map((file) => path.resolve(basedir, file)),\n      compilerOptions,\n      compilerHost\n    );\n  }\n\n  findTokens(token: string, node: ts.Node) {\n    const [lookFor, ...tail] = token.split('.');\n    const found: ts.Node[] = [];\n    node.forEachChild((child: ts.Node & { name?: ts.Node }) => {\n      if (ts.isVariableStatement(child)) {\n        found.push(...this.findTokens(token, child.declarationList));\n        if (child.declarationList.declarations.length === 1) {\n          const name = child.declarationList.declarations[0].name;\n          if (name && ts.isIdentifier(name) && name.escapedText === lookFor) {\n            // push the whole declarationList if it contains only one declaration, for \"outside style\"\n            found.push(child);\n          }\n        }\n        return;\n      }\n\n      const name = child.name;\n      if (name && ts.isIdentifier(name) && name.escapedText === lookFor) {\n        if (lookFor === token) {\n          if (ts.isVariableDeclaration(child) && child.initializer) {\n            // push the initializer for \"inside\" style\n            found.push(child.initializer);\n          }\n          found.push(child);\n        } else {\n          found.push(...this.findTokens(tail.join('.'), child));\n        }\n      }\n    });\n    return found;\n  }\n\n  getComment(token: string, fileName = 'index.ts', overload = 0) {\n    const inputFileName = path.resolve(this.basedir, fileName);\n    const sourceFile = this.program.getSourceFile(inputFileName);\n    if (!sourceFile) {\n      throw new Error(\n        `Error retrieving source file ${sourceFile} (looked for ${fileName} in ${this.basedir})`\n      );\n    }\n\n    const foundComments = [];\n\n    const buffer = sourceFile.getFullText();\n\n    for (const node of this.findTokens(token, sourceFile)) {\n      const comments = getJSDocCommentRanges(node, buffer);\n\n      if (comments.length > 0) {\n        for (const comment of comments) {\n          foundComments.push({\n            compilerNode: node,\n            textRange: tsdoc.TextRange.fromStringRange(\n              buffer,\n              comment.pos,\n              comment.end\n            ),\n          });\n        }\n      }\n    }\n\n    const customConfiguration = new tsdoc.TSDocConfiguration();\n\n    customConfiguration.addTagDefinition(\n      new tsdoc.TSDocTagDefinition({\n        tagName: '@overloadSummary',\n        syntaxKind: tsdoc.TSDocTagSyntaxKind.BlockTag,\n      })\n    );\n\n    customConfiguration.addTagDefinition(\n      new tsdoc.TSDocTagDefinition({\n        tagName: '@overloadRemarks',\n        syntaxKind: tsdoc.TSDocTagSyntaxKind.BlockTag,\n      })\n    );\n\n    const tsdocParser = new tsdoc.TSDocParser(customConfiguration);\n\n    const selectedOverload = foundComments[overload];\n    if (!selectedOverload) {\n      console.warn(\n        `could not find overload ${overload} for ${token} in ${fileName}`\n      );\n      return null;\n    }\n\n    const parserContext = tsdocParser.parseRange(selectedOverload.textRange);\n    const docComment = parserContext.docComment;\n    return Object.assign(docComment, {\n      parserContext,\n      buffer: selectedOverload.textRange.buffer,\n      overloadSummary: docComment.customBlocks.find(\n        this.byTagName('@overloadSummary')\n      ),\n      overloadRemarks: docComment.customBlocks.find(\n        this.byTagName('@overloadRemarks')\n      ),\n      examples: docComment.customBlocks.filter(this.byTagName('@example')),\n    });\n  }\n\n  byTagName(name: string) {\n    return (block: tsdoc.DocBlock) => block.blockTag.tagName === name;\n  }\n}\n","// @ts-ignore\nimport flatMap from 'unist-util-flatmap';\nimport { Extractor, ExtractorSettings } from './extract';\nimport { renderDocNode } from './utils';\nimport { URL } from 'url';\nimport type { Node, Parent } from 'unist';\nimport visit from 'unist-util-visit';\n\nimport type { Plugin } from 'unified';\nimport type { DocNode } from '@microsoft/tsdoc';\n\ntype Comment = NonNullable<ReturnType<Extractor['getComment']>>;\ntype RenderFunction = (c: Comment) => import('unist').Node[];\n\ntype RenderableKey = {\n  [K in keyof Comment]: NonNullable<Comment[K]> extends DocNode | DocNode[]\n    ? K\n    : never;\n}[keyof Comment];\n\nexport interface Settings {\n  extractorSettings: ExtractorSettings;\n}\n\nconst extractors = new WeakMap<ExtractorSettings, Extractor>();\n\nexport const attacher: Plugin<[Settings]> = function ({ extractorSettings }) {\n  if (!extractors.has(extractorSettings)) {\n    extractors.set(extractorSettings, new Extractor(extractorSettings));\n  }\n  const extractor = extractors.get(extractorSettings)!;\n\n  const parseNodes = (markdown: string): Node[] => {\n    return (this.parse(markdown) as Parent).children;\n  };\n\n  function renderAsMarkdown(\n    key: RenderableKey,\n    prepare = (str: string) => str\n  ): RenderFunction {\n    function render(comment: Comment) {\n      const docBlock = comment[key];\n      const rendered = renderDocNode(docBlock);\n      return parseNodes(prepare(rendered));\n    }\n    return render;\n  }\n\n  const sectionMapping = {\n    summary: renderAsMarkdown('summarySection', (s) =>\n      s.replace(/@summary/g, '')\n    ),\n    remarks: renderAsMarkdown('remarksBlock', (s) =>\n      s.replace(/@remarks/g, '')\n    ),\n    overloadSummary: renderAsMarkdown('overloadSummary', (s) =>\n      s.replace(/@overloadSummary/g, '')\n    ),\n    overloadRemarks: renderAsMarkdown('overloadRemarks', (s) =>\n      s.replace(/@overloadRemarks/g, '')\n    ),\n    examples: renderAsMarkdown('examples', (s) => s.replace(/@example/g, '')),\n    params: renderAsMarkdown('params', (s) =>\n      s.replace(/@param (.*) -/g, '* **$1**')\n    ),\n  };\n\n  return function transformer(tree) {\n    return flatMap(tree, function mapper(parent: Parent): Node[] {\n      if (!(parent.type === 'paragraph' && parent.children.length === 1)) {\n        return [parent];\n      }\n\n      const node = parent.children[0] as Node & {\n        url: string;\n        children: [import('unist').Node & { value: string }];\n      };\n\n      if (node.type !== 'link' || !node.url.startsWith('docblock://')) {\n        return [parent];\n      }\n\n      if (node.children.length !== 1 || node.children[0].type !== 'text') {\n        throw new Error('invalid meta content for docblock link');\n      }\n      const meta = node.children[0].value;\n      const sections = meta.split(',').map((s) => s.trim());\n\n      const url = new URL(node.url);\n      const fileName = url.host + url.pathname;\n      const args = url.searchParams;\n\n      const token = args.get('token');\n      const overload = Number.parseInt(args.get('overload') || '0');\n\n      if (!token) {\n        throw new Error(\n          'token name must be provided as query parameter `token`'\n        );\n      }\n\n      const comment = extractor.getComment(token, fileName, overload);\n      if (!comment) {\n        return [];\n      }\n\n      const retVal = sections.reduce<Node[]>((acc, section) => {\n        if (!(section in sectionMapping)) {\n          throw new Error(\n            `invalid comment section reference. valid references are ${Object.keys(\n              sectionMapping\n            ).concat(',')}`\n          );\n        }\n        acc.push(\n          ...sectionMapping[section as keyof typeof sectionMapping](comment)\n        );\n        return acc;\n      }, []);\n\n      visit<\n        Node & { value: string }\n      >({ type: 'fakeRoot', children: retVal }, 'code', (node) => {\n        node.value = node.value.trimEnd();\n      });\n\n      return retVal;\n    });\n  };\n};\n","import ts from 'typescript';\nimport { normalize } from 'path';\n\nimport { VirtualFiles, VirtualFile } from './plugin';\n\nexport type Diagnostic =\n  | { line: number; character: number; message: string }\n  | { line?: undefined; character?: undefined; message: string };\n\nexport interface TranspiledFile extends VirtualFile {\n  diagnostics: Array<Diagnostic>;\n}\n\nexport type TranspiledFiles = Record<string, TranspiledFile>;\n\nexport interface ExternalResolution {\n  resolvedPath: string;\n  packageId: ts.PackageId;\n}\n\nexport interface CompilerSettings {\n  tsconfig: string;\n  externalResolutions: Record<string, ExternalResolution>;\n}\n\nexport class Compiler {\n  private service: ts.LanguageService;\n  private compilerOptions: ts.CompilerOptions;\n  private compilerHost: ReturnType<typeof createCompilerHost>;\n\n  constructor(settings: CompilerSettings) {\n    const configFile = ts.readConfigFile(settings.tsconfig, ts.sys.readFile);\n    this.compilerOptions = ts.parseJsonConfigFileContent(\n      configFile.config,\n      ts.sys,\n      './'\n    ).options;\n\n    this.compilerHost = createCompilerHost(\n      this.compilerOptions,\n      settings.externalResolutions\n    );\n    this.service = ts.createLanguageService(\n      this.compilerHost,\n      ts.createDocumentRegistry()\n    );\n  }\n\n  public compile(files: VirtualFiles) {\n    // console.log(compilerOptions)\n\n    this.compilerHost.setScriptFileNames([]);\n    for (let [fileName, { code }] of Object.entries(files)) {\n      code = code.replace(/^$/gm, '//__NEWLINE__');\n      this.compilerHost.writeFile(fileName, code);\n    }\n    this.compilerHost.setScriptFileNames(Object.keys(files));\n\n    const returnFiles: TranspiledFiles = {};\n\n    for (const [fileName] of Object.entries(files)) {\n      const emitResult = this.service.getEmitOutput(fileName);\n      const emittedFile = emitResult.outputFiles.find(\n        ({ name }) => name.endsWith('.js') || name.endsWith('.jsx')\n      );\n      const transpiledCode = emittedFile\n        ? emittedFile.text.replace(/\\/\\/__NEWLINE__/g, '')\n        : '';\n\n      const allDiagnostics = this.service\n        .getCompilerOptionsDiagnostics()\n        .concat(this.service.getSyntacticDiagnostics(fileName))\n        .concat(this.service.getSemanticDiagnostics(fileName));\n\n      const diagnostics = allDiagnostics.map((diagnostic) => {\n        const message = ts.flattenDiagnosticMessageText(\n          diagnostic.messageText,\n          '\\n'\n        );\n        if (diagnostic.file && diagnostic.start) {\n          const {\n            line,\n            character,\n          } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);\n          return { line, character, message };\n        }\n        return { message };\n      });\n      returnFiles[fileName] = {\n        ...files[fileName],\n        code: transpiledCode,\n        diagnostics,\n      };\n    }\n\n    return returnFiles;\n  }\n}\n\nfunction createCompilerHost(\n  compilerOptions: ts.CompilerOptions,\n  externalResolutions: CompilerSettings['externalResolutions']\n): ts.LanguageServiceHost &\n  ts.ModuleResolutionHost &\n  Required<Pick<ts.LanguageServiceHost, 'writeFile'>> & {\n    setScriptFileNames(files: string[]): void;\n  } {\n  const virtualFiles: Record<\n    string,\n    { contents: string; version: number }\n  > = {};\n  let scriptFileNames: string[] = [];\n\n  return {\n    ...ts.createCompilerHost(compilerOptions),\n    getCompilationSettings() {\n      return compilerOptions;\n    },\n    fileExists(fileName) {\n      // console.log('fileExists', fileName)\n      return !!virtualFiles[normalize(fileName)] || ts.sys.fileExists(fileName);\n    },\n    readFile(fileName: string) {\n      // console.log('readFile', fileName)\n      const virtual = virtualFiles[normalize(fileName)];\n      return virtual ? virtual.contents : ts.sys.readFile(fileName);\n    },\n    writeFile(fileName, contents) {\n      fileName = normalize(fileName);\n      let version = virtualFiles[fileName] ? virtualFiles[fileName].version : 1;\n      if (\n        virtualFiles[fileName] &&\n        virtualFiles[fileName].contents !== contents\n      ) {\n        version++;\n      }\n      virtualFiles[fileName] = { contents, version };\n    },\n    directoryExists(dirName) {\n      const normalized = normalize(dirName + '/');\n      return (\n        scriptFileNames.some((fileName) => fileName.startsWith(normalized)) ||\n        ts.sys.directoryExists(dirName)\n      );\n    },\n    setScriptFileNames(files) {\n      scriptFileNames = files.map(normalize);\n      // console.log({ virtualFiles, scriptFileNames })\n    },\n    getScriptFileNames() {\n      return scriptFileNames;\n    },\n    getScriptSnapshot(fileName) {\n      const contents = this.readFile(fileName);\n      return contents ? ts.ScriptSnapshot.fromString(contents) : undefined;\n    },\n    getScriptVersion(fileName) {\n      const virtual = virtualFiles[normalize(fileName)];\n      return virtual\n        ? virtual.version.toString()\n        : String(\n            (ts.sys.getModifiedTime && ts.sys.getModifiedTime(fileName)) ||\n              'unknown, will not update without restart'\n          );\n    },\n    resolveModuleNames(moduleNames, containingFile) {\n      return moduleNames.map((moduleName) => {\n        if (moduleName in externalResolutions) {\n          const resolved = externalResolutions[moduleName];\n\n          const resolvedModule = ts.resolveModuleName(\n            resolved.resolvedPath,\n            containingFile,\n            compilerOptions,\n            this\n          ).resolvedModule;\n          if (!resolvedModule) {\n            throw new Error(`external resolution ${moduleName} not found`);\n          }\n          return {\n            ...resolvedModule,\n            packageId: resolved.packageId,\n          };\n        }\n\n        return ts.resolveModuleName(\n          moduleName,\n          containingFile,\n          compilerOptions,\n          this\n        ).resolvedModule;\n      });\n    },\n  };\n}\n","import visit from 'unist-util-visit';\n// @ts-ignore\nimport flatMap from 'unist-util-flatmap';\nimport { Compiler, CompilerSettings, TranspiledFile } from './compiler';\nimport {\n  postProcessTranspiledJs as defaultPostProcessTranspiledJs,\n  postProcessTs as defaultPostProcessTs,\n} from './postProcessing';\nimport type { Plugin } from 'unified';\nimport type { Node, Parent } from 'unist';\nimport type { VFile } from 'vfile';\n\nexport interface VirtualFile {\n  code: string;\n  skip?: boolean;\n}\nexport type VirtualFiles = Record<string, VirtualFile>;\n\ninterface CodeNode extends Node {\n  lang: string;\n  meta: string;\n  value: string;\n  indent: number[];\n}\n\ntype PostProcessor = (\n  files: VirtualFiles,\n  parentFile?: string,\n  defaultProcessor?: PostProcessor\n) => VirtualFiles;\n\nexport interface Settings {\n  compilerSettings: CompilerSettings;\n  postProcessTranspiledJs?: PostProcessor;\n  postProcessTs?: PostProcessor;\n  assembleReplacementNodes?: typeof defaultAssembleReplacementNodes;\n  fileExtensions?: string[];\n}\n\nconst compilers = new WeakMap<CompilerSettings, Compiler>();\n\nexport const attacher: Plugin<[Settings]> = function ({\n  compilerSettings,\n  postProcessTranspiledJs = defaultPostProcessTranspiledJs,\n  postProcessTs = defaultPostProcessTs,\n  assembleReplacementNodes = defaultAssembleReplacementNodes,\n  fileExtensions = ['.mdx'],\n}) {\n  if (!compilers.has(compilerSettings)) {\n    compilers.set(compilerSettings, new Compiler(compilerSettings));\n  }\n  const compiler = compilers.get(compilerSettings)!;\n\n  return function transformer(tree, file) {\n    if (!file.extname || !fileExtensions.includes(file.extname)) {\n      return tree;\n    }\n\n    let hasTabsImport = false;\n    let hasTabItemImport = false;\n\n    visit<Node & { value: string }>(tree, 'import', (node) => {\n      if (/\\bTabs\\b/.test(node.value)) hasTabsImport = true;\n      if (/\\bTabItem\\b/.test(node.value)) hasTabItemImport = true;\n    });\n\n    visit<Parent>(tree, 'root', (node) => {\n      if (!hasTabsImport) {\n        node.children.unshift({\n          type: 'import',\n          value: `import Tabs from '@theme/Tabs'`,\n        });\n      }\n      if (!hasTabItemImport) {\n        node.children.unshift({\n          type: 'import',\n          value: `import TabItem from '@theme/TabItem'`,\n        });\n      }\n    });\n\n    let codeBlock = 0;\n\n    return flatMap(tree, function mapper(node: CodeNode): Node[] {\n      if (node.type === 'code') {\n        codeBlock++;\n      }\n      if (!(node.type === 'code' && node.lang === 'ts')) {\n        return [node];\n      }\n      const tags = node.meta ? node.meta.split(' ') : [];\n      if (tags.includes('no-transpile')) {\n        return [node];\n      }\n\n      const virtualFolder = `${file.path}/codeBlock_${codeBlock}`;\n      const virtualFiles = splitFiles(node.value, virtualFolder);\n\n      //console.time(virtualFolder)\n      const transpilationResult = compiler.compile(virtualFiles);\n      //console.timeEnd(virtualFolder)\n\n      for (const [fileName, result] of Object.entries(transpilationResult)) {\n        for (const diagnostic of result.diagnostics) {\n          if (diagnostic.line && node.position) {\n            const lines = result.code\n              .split('\\n')\n              .map(\n                (line, lineNo) => `${String(lineNo).padStart(3, ' ')}  ${line}`\n              );\n\n            file.fail(\n              `\nTypeScript error in code block in line ${diagnostic.line} of ${fileName}\n${diagnostic.message}\n\n${lines.slice(Math.max(0, diagnostic.line - 5), diagnostic.line + 6).join('\\n')}\n            `,\n              {\n                line: diagnostic.line + node.position.start.line,\n                column: diagnostic.character,\n              }\n            );\n          } else {\n            file.fail(diagnostic.message, node);\n          }\n        }\n      }\n\n      return assembleReplacementNodes(\n        node,\n        file,\n        virtualFolder,\n        virtualFiles,\n        transpilationResult,\n        postProcessTs,\n        postProcessTranspiledJs\n      );\n    });\n  };\n};\n\nfunction defaultAssembleReplacementNodes(\n  node: CodeNode,\n  file: VFile,\n  virtualFolder: string,\n  virtualFiles: Record<string, VirtualFile>,\n  transpilationResult: Record<string, TranspiledFile>,\n  postProcessTs: PostProcessor,\n  postProcessTranspiledJs: PostProcessor\n) {\n  return [\n    {\n      type: 'jsx',\n      value: `\n    <Tabs\n      groupId=\"language\"\n      defaultValue=\"ts\"\n      values={[\n        { label: 'TypeScript', value: 'ts', },\n        { label: 'JavaScript', value: 'js', },\n      ]}\n    >        \n        <TabItem value=\"ts\">`,\n    },\n    {\n      ...node,\n      value: rearrangeFiles(\n        postProcessTs(virtualFiles, file.path, defaultPostProcessTs),\n        virtualFolder\n      ),\n    },\n    {\n      type: 'jsx',\n      value: `\n        </TabItem>\n        <TabItem value=\"js\">`,\n    },\n    {\n      ...node,\n      lang: 'js',\n      value: rearrangeFiles(\n        postProcessTranspiledJs(\n          transpilationResult,\n          file.path,\n          defaultPostProcessTranspiledJs\n        ),\n        virtualFolder\n      ),\n    },\n    {\n      type: 'jsx',\n      value: `\n        </TabItem>\n    </Tabs>`,\n    },\n  ];\n}\n\nfunction splitFiles(fullCode: string, folder: string) {\n  const regex = /^\\/\\/ file: ([\\w\\-./]+)(?: (.*))?\\s*$/gm;\n  let match = regex.exec(fullCode);\n\n  let files: VirtualFiles = {};\n\n  do {\n    const start = match ? match.index + match[0].length + 1 : 0;\n    const fileName = match ? match[1] : 'index.ts';\n    const flags = (match ? match[2] || '' : '').split(' ');\n    const skip = flags.includes('noEmit');\n    match = regex.exec(fullCode);\n    const end = match ? match.index : fullCode.length;\n    const code = fullCode.substring(start, end);\n    files[`${folder}/${fileName}`] = { code, skip };\n  } while (match);\n\n  return files;\n}\n\nfunction rearrangeFiles(files: VirtualFiles, folder: string) {\n  const filteredFiles = Object.entries(files).filter(([, { skip }]) => !skip);\n\n  if (filteredFiles.length === 1) {\n    const [[, { code }]] = filteredFiles;\n    return code;\n  }\n\n  return filteredFiles\n    .map(\n      ([fileName, { code }]) => `// file: ${fileName.replace(folder + '/', '')}\n${code.trim()}`\n    )\n    .join('\\n\\n\\n');\n}\n"],"names":["getJSDocCommentRanges","node","text","commentRanges","kind","ts","SyntaxKind","Parameter","TypeParameter","FunctionExpression","ArrowFunction","ParenthesizedExpression","VariableDeclaration","VariableStatement","push","getTrailingCommentRanges","pos","getLeadingCommentRanges","filter","comment","charCodeAt","lastConfig","Extractor","tsconfig","rootFiles","basedir","configFile","readConfigFile","sys","readFile","compilerOptions","parseJsonConfigFileContent","config","options","compilerHost","createCompilerHost","program","createProgram","map","file","path","resolve","findTokens","token","split","lookFor","tail","found","forEachChild","child","isVariableStatement","_this","declarationList","declarations","length","name","isIdentifier","escapedText","isVariableDeclaration","initializer","join","getComment","fileName","overload","inputFileName","this","sourceFile","getSourceFile","Error","foundComments","buffer","getFullText","comments","compilerNode","textRange","tsdoc","fromStringRange","end","customConfiguration","addTagDefinition","tagName","syntaxKind","BlockTag","tsdocParser","selectedOverload","console","warn","parserContext","parseRange","docComment","Object","assign","overloadSummary","customBlocks","find","byTagName","overloadRemarks","examples","block","blockTag","extractors","WeakMap","Compiler","settings","externalResolutions","virtualFiles","scriptFileNames","getCompilationSettings","fileExists","normalize","virtual","contents","writeFile","version","directoryExists","dirName","normalized","some","startsWith","setScriptFileNames","files","getScriptFileNames","getScriptSnapshot","ScriptSnapshot","fromString","undefined","getScriptVersion","toString","String","getModifiedTime","resolveModuleNames","moduleNames","containingFile","moduleName","resolved","resolvedModule","resolveModuleName","resolvedPath","packageId","service","createLanguageService","createDocumentRegistry","compile","entries","code","replace","keys","returnFiles","emittedFile","getEmitOutput","outputFiles","endsWith","transpiledCode","diagnostics","getCompilerOptionsDiagnostics","concat","getSyntacticDiagnostics","getSemanticDiagnostics","diagnostic","message","flattenDiagnosticMessageText","messageText","start","getLineAndCharacterOfPosition","line","character","postProcessTs","parentFile","fromEntries","prettify","trim","postProcessTranspiledJs","mangledCode","sourceCode","lastParentFile","prettier","resolveConfig","sync","format","filepath","error","ret","compilers","defaultAssembleReplacementNodes","virtualFolder","transpilationResult","type","value","rearrangeFiles","defaultPostProcessTs","lang","defaultPostProcessTranspiledJs","folder","filteredFiles","skip","extractorSettings","has","set","extractor","get","renderAsMarkdown","key","prepare","str","markdown","rendered","renderDocNode","docNode","Array","isArray","result","meta","_line","metaMatch","language","content","getChildNodes","parse","children","sectionMapping","summary","s","remarks","params","tree","flatMap","parent","url","sections","URL","host","pathname","args","searchParams","Number","parseInt","retVal","reduce","acc","section","visit","trimEnd","compilerSettings","assembleReplacementNodes","fileExtensions","compiler","extname","includes","hasTabsImport","hasTabItemImport","test","unshift","codeBlock","fullCode","regex","match","exec","index","substring","splitFiles","position","lines","lineNo","padStart","fail","slice","Math","max","column"],"mappings":"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"}